# -*- coding: utf-8 -*-
"""Eq_B_Modelo_Clustering_K_means.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lQj3au8UnyAP7Pika900BnwbchQJqYHg

# Eq.B.Proyecto - Modelos de Clasificación
"""

import pandas as pd
import numpy as np
import matplotlib as plt
import matplotlib.pyplot as plt
from matplotlib import style
import seaborn as sns
import math
import warnings

warnings.filterwarnings("ignore")
style.use('ggplot')
pd.set_option('display.max_columns', None)
pd.set_option('display.float_format', lambda x: '%.3f' % x)


import yfinance as yf
# Dataset de Microsoft Corporation (MSFT)
msft = yf.Ticker('MSFT')
df = msft.history(period="max", auto_adjust=True)
df

#eliminamos las variables sin valores
df = df.drop(['Dividends'], axis='columns')
df = df.drop(['Stock Splits'], axis='columns')
df

"""## Variables adicionales:

RSI (Indicador de fuerza relativa):
"""

delta = df['Close'].diff()
up = delta.clip(lower = 0)
down = -1*delta.clip(upper=0)
ema_up = up.ewm(com=13, adjust=False).mean()
ema_down = down.ewm(com=13, adjust=False).mean()
rs = ema_up/ema_down
df['RSI'] = 100 - (100/(1+rs))
df

"""MACD:"""

exp1 = df['Close'].ewm(span=12, adjust=False).mean()
exp2 = df['Close'].ewm(span=26, adjust=False).mean()
df['MACD'] = exp1 -exp2
df['Signal line'] = df['MACD'].ewm(span=9, adjust=False).mean()

df.head()

"""Eliminando valores perdidos (faltantes)"""

df.isnull().sum()

#Quitamos las filas que tengan el valor de NaN
df=df.dropna()
df

"""Seleccionamos las características para el modelo"""

data = df[['Open', 'High', 'Low','Close', 'Volume','RSI', 'MACD']]
data.head()

# Información del dataset
data.info()

"""Obtenemos las Estadísticas Descriptivas de las variables"""

data.describe()

"""Normalizamos los valores de las características"""

data_norm = (data - data.min())/(data.max() - data.min())
data_norm

data_norm.describe()

"""## MODELOS DE CLUSTERING

## Modelo K-means.
"""

from sklearn.cluster import KMeans

"""## Busquemos la cantidad optima de Clusters

Calculamos que tan similares son los datos dentro de los clusters
"""

# WCSS es la suma de los cuadrados de las distancias y se refiere a Within-Cluster-Sum-of-Squares,
# Yi es el centroide del elemento o dato Xi y n el total de datos en la muestra.

wcss = []

for i in range(1,11):
  kmeans = KMeans(n_clusters=i, max_iter = 1000)
  kmeans.fit(data_norm) #Aplicamos k-means a la base de datos
  wcss.append(kmeans.inertia_)

"""Graficamos los resultados de WCSS para formar el Codo de Jambú"""

plt.plot(range(1,11), wcss)
plt.xlabel('Número de Clusters')
plt.ylabel('WCSS') # Indica que tan similares son los datos dentro de los Clusters
plt.title('Codo de Jambú')
plt.show()

"""Elegimos un punto donde el valor de WCSS deje de diminuir de manera drástica, que es valor 3

Aplicamos el modelo de k-means a la base de datos
"""

clustering = KMeans(n_clusters=3, max_iter = 1000) # crea el modelo

clustering.fit(data_norm) # Aplicamos el modelo a la base de datos

"""Agregamos la calificacion al datafreme para los modelos"""

data['KMeans_Clusters'] = clustering.labels_ # los resultados del clustering se guardan en labes_ dentro del modelo
data.head()

"""### Visualizamos los Clusters que se formaron

Aplicamos el Análisis de Componentes Principales (PCA) para darnos una idea de como se forma los clusters
"""

from sklearn.decomposition import PCA

pca = PCA(n_components = 2).fit_transform(data_norm)

pca_df = pd.DataFrame(data=pca, columns=['Componente_1', 'Componente_2'])


data_cluster =  pd.DataFrame(data =  clustering.labels_,columns=['Grupo'])

pca_cont = pd.concat([pca_df, data_cluster], axis=1)

pca_cont

"""Usamos Matplotlib, que es una librería de Python especializada en la creación de gráficos en dos dimensiones"""

fig = plt.figure(figsize=(6,6))

ax = fig.add_subplot(1,1,1)
ax.set_xlabel('Componente 1', fontsize = 15)
ax.set_ylabel('Componente 2', fontsize = 15)
ax.set_title('Componentes principales', fontsize = 20)

color_theme = np.array(['blue', 'green', 'orange'])
ax.scatter(x = pca_cont.Componente_1, y= pca_cont.Componente_2, c=color_theme[pca_cont.Grupo], s=50)

plt.show()

